-------------------------------------------------------------------------------
RTP text/t140 library

Authors: 
  Andreas Piirimets, Omnitor AB
  Erik Zetterström, Omnitor AB

Copyright (C) 2004-2008 Board of Regents of the University of Wisconsin System
(Univ. of Wisconsin-Madison, Trace R&D Center)
Copyright (C) 2004-2008 Omnitor AB

This software was developed with support from the National Institute on
Disability and Rehabilitation Research, US Dept of Education under Grant
# H133E990006 and H133E040014  

This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or (at
your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Please send a copy of any improved versions of the library to: 
Gunnar Hellstrom, Omnitor AB, Renathvagen 2, SE 121 37 Johanneshov, SWEDEN
Gregg Vanderheiden, Trace Center, U of Wisconsin, Madison, Wi 53706

-------------------------------------------------------------------------------

--------------------
IMPLEMENTATION GUIDE
--------------------

This document describes how to use RTP text/t140 library.


1. What is RTP text/t140 library?
---------------------------------

RTP text/t140 library is a software package that can be used in a soft phone
or any other application that wants to use the RTP payload type for text conversation specification (RFC 4103, former RFC 2793).

RTP text/t140 library consists of these parts:

- RTP packetizer and depacketizer for text/t140
- Code for text buffering
- Classes for using the packetizer and depacketizer with JMF
- Example code files, showing how to use the package 

Making and parsing RTP packets, including redundancy handling, are 
managed in the packetizer/depacketizer.
 
RFC 4103 recommends text buffering and re-sending in silent periods (when using
redundancy). This is handeled in the SyncBuffer.


2. Compiling and generating Javadoc
-----------------------------------

The whole project is compiled by using the "compile.bat" file found in the
src directoy.

All classes have Javadoc comments, Javadoc is generated by running the
"makeJavadoc.bat" file found in the root directory. Normally, a Javadoc is
already created and delivered with the package. It is found under the
javadoc/ directory.

NOTE! If JMF is not installed, compilation errors will occur for the JMF
example files! Please download the latest version of JMF from
http://java.sun.com/jmf.



3. Class hierarchy
------------------

The library consists of the following packages:

se.omnitor.media.content.text.t140  - Plug-in classes for JMF
se.omnitor.media.protocol.text.t140 - Plug-in classes for JMF
se.omnitor.protocol.rtp.text        - Packetizer, depacketizer, buffering
se.omnitor.util                     - A FIFO buffer


4. Text packetizer and depacketizer
-----------------------------------

4.1  RtpTextPacketizer

In se.omnitor.protocol.rtp.text, a RtpTextPacketizer is found. This class
handles encoding of RTP packets according to RFC 4103.

This class also holds information about redundant generations.

To use this class, make an instance of it and call the encode(..) function
for every packet that should be sent.


4.2  RtpTextDePacketizer

In se.omnitor.protocol.rtp.text, a RtpTextDePacketizer is found. This class
handles decoding of incoming RTP packets according to RFC 4103.

This class saves redundant data and restores it if packets are lost.

To use this class, make an instance of it and call the decode(..) function
for every packet that should be decoded.


4.3  RtpTextBuffer

When sending data to and from the packetizer and depacketizer, the
RtpTextBuffer object is used. This objects holds information about the packet
data, but also sequence number, data length, timestamp and more.



5. Buffering
------------

5.1  SyncBuffer

When locally written characters are to be sent over the network, they should
first pass the SyncBuffer. This is a FIFO buffer, which is suitable to use
in between the GUI and the RTP parts.

Accoring to RFC 4103, data should be buffered in 300 ms before sending. If
redundancy is used and no data has been written for 300 ms, redundant packets
should be sent with empty data. All this is handled by the SyncBuffer.


5.2  FifoBuffer

Data from DePacketizer to GUI is placed in a FifoBuffer. This is a plain FIFO
buffer, nothing strange.



6. How to use RTP text/t140 with JMF
------------------------------------

6.1  DataSource

There is a datasoure in se.omnitor.media.protocol.text.t140, this handles all
locally written data.

First, "se.omnitor" has to be registered as a content and package prefix in
JMF, this is either carried out in JMF Registry or with this code:

  // The new content and package prefix
  String myPackagePrefix = new String("se.omnitor");     

  // Add new package prefix
  Vector packagePrefix = PackageManager.getProtocolPrefixList();
  if (packagePrefix.indexOf(myPackagePrefix) == -1) {
      packagePrefix.addElement(myPackagePrefix);
      PackageManager.setProtocolPrefixList(packagePrefix);
      PackageManager.commitProtocolPrefixList();
  }
    
  // Add new content prefix
  Vector contentPrefix = PackageManager.getContentPrefixList();    
  if (contentPrefix.indexOf(myPackagePrefix) == -1) {
      contentPrefix.addElement(myPackagePrefix);
      PackageManager.setContentPrefixList(contentPrefix);
      PackageManager.commitContentPrefixList();
  }

Then, the datasource may be accessed with the locator "text.t140:". There are
three different arguments that works with this locator, these are:

  text.t140:stdin  - Reads characters from stdin
  text.t140:buffer - Reads cahracters from a given SyncBuffer

("text.t140:" will give the same result as "text.t140:buffer")

When using stdin, remember that there is no way to read character by character
from stdin with Java! Only complete lines will be read.

When using buffer, a SyncBuffer has to be set to the datasource. Then, put
locally written characters to the SyncBuffer (read more about SyncBuffer
below).



6.2  Player

In order to get incoming text from JMF receiver, a TextPlayer is used. This
TextPlayer should be registered as a renderer in JMF, it could be done like 
this:

  track.setRenderer(textPlayer);

The text player puts all incoming text in a FifoBuffer, this buffer object
has to be created externally and passed to the TextPlayer via the constructor:

  FifoBuffer fifoBuffer = new FifoBuffer();
  TextPlayer textPlayer = new TextPlayer(fifoBuffer);

Fetch data with the getData(..) function.



6.3  Transmit with RTP

In se.omnitor.media.protocol.text.t140, there is a class named TextPacketizer.
This is a JMF Codec, which should be used when sending RTP data.

The codec has to be put into the codec chain with the following example
code:

  Codec[] chain = new Codec[] { new TextPacketizer(t140Pt, redPt, redGen) };
  try {
      track.setCodecChain(chain);    
  }
  ..

A complete JMF text transmitter is found in src/examples/jmf/TextTransmit.java.



6.4  Receive with RTP

A TextDePacketizer is available in se.omnitor.media.protocol.text.t140. This
is a JMF Codec, which should be used when receiving RTP data.

The codec has to be put into the codec chain, se an example in section 6.2.

A complete JMF text receiver is found in src/examples/jmf/TextReceive.java.



7. Further information
----------------------

For questions, bug reports, feature requests or other comments, please visit
the SourceForge project page:

  http://sourceforge.net/projects/rtp-text-t140/

or email Andreas Piirimets at Omnitor AB (andreas.piirimets@omnitor.se).

-------------------------------------------------------------------------------